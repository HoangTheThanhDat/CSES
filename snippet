{
"cpp": {
  "prefix": ["xz" , "sa" , "xzc" , "sda" , "datmacoder" , "datma._coder" , "cxz" , "czx" , "datamcoder" , "dsa" , "das" , "cpp" , "fds"],
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define      ll      long long",
    "#define      fi      first ",
    "#define      se      second ",
    "#define      el      '\\n'",
    "",
    "#define reset(__a , __v) memset(__a,__v,sizeof(__a))",
    "#define datmacoder int32_t main()",
    "#define opf(__dat) if (fopen(__dat\".inp\",\"r\")){freopen(__dat\".inp\",\"r\",stdin);freopen(__dat\".out\",\"w\",stdout);}",
    "#define openfile(__dat) opf(__dat);int _t;if(!TESTCASE)_t=1;else cin>>_t;while(_t--){solve();} ",
    "",
    "template<class A,class B> inline void maximize(A& x, B y) {x = max(x, y);};",
    "template<class A,class B> inline void minimize(A& x, B y) {x = min(x, y);};",
    "",
    "const int maxn = 2e5 + 68;",
    "const int mod = 1e9 + 7;",
    "const int inf = 0x3f3f3f3f;",
    "const ll infll = 0x3f3f3f3f3f3f3f3f;",
    "const bool TESTCASE = false;",
    "",
    "//  ------------------- d a t m a . _ c o d e r -------------------  //",
    "",
    "",
    "",
    "void solve() {",
    "",
    "}",
    "",
    "datmacoder {",
    "        ios_base::sync_with_stdio(false);",
    "        cin.tie(NULL); cout.tie(NULL);",
    "",
    "        openfile(\"nofile\");",
    "",
    "        return 0;",
    "}",
    "",
    "/* ",
    "        d a t m a . _ c o d e r",
    "        H O A N G   T H E   T H A N H   D A T",
    "*/"
  ],
  "description": "cpp"
},

"gen-code": {
  "prefix": ["gencpp"],
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int main() {",
    "        //freopen(\"Ansrew.txt\" , \"w\" , stdout);",
    "        for (int i = 1 ; i <= 10 ; i++) {",
    "                system(\"sinh.exe\");",
    "                system(\"trau.exe\");",
    "                system(\"txt.exe\");",
    "",
    "                cout << \"TEST \" << i << \":  \";",
    "",
    "                if (system(\"fc txt.out txt.ans\") != 0) {",
    "                        cout << \"[ WRONG ANSWER ]\" << endl;",
    "                        return 0;",
    "                }",
    "                else {",
    "                        cout << \"[ ACCEPTED ]\" << endl;",
    "                }",
    "    }",
    "}"
  ],
  "description": "gencode"
},

"random-test": {
  "prefix": ["ran" , "sinh" , "test"],
  "body": [
    "#include   <bits/stdc++.h>",
    "#include   <cstdlib>",
    "",
    "using namespace std;",
    "",
    "#define    ll          long long",
    "#define    fi          first",
    "#define    se          second",
    "#define    sz          size",
    "#define    reset(adatma , valdatma) memset(adatma , valdatma ,sizeof(adatma))",
    "#define    el '\\n'",
    "",
    "template <class DATMA> inline bool maximize(DATMA &a , DATMA b) { return (a < b) ? a = b , true : false;}",
    "template <class DATMA> inline bool minimize(DATMA &a , DATMA b) { return (a > b) ? a = b , true : false;}",
    "",
    "const int maxn = 2 * 1e5 + 68;",
    "const int mod = 1e9 + 7;",
    "const int inf = 2 * 1e9 + 1e8 + 6688;",
    "const ll oo = 3 * 1e18 + 1e17 + 666888;",
    "",
    "//  ------------------- d a t m a . _ c o d e r -------------------  //",
    "",
    "mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "ll Rand(ll l , ll r) {",
    "        assert(l <= r);",
    "",
    "        if (r - l + 1 >= 1e9) {",
    "",
    "        ll a = rd() / 2 , b = rd() / 2;",
    "",
    "        if (a % 2 == 1 && b % 2 == 0) {",
    "                if (b == 0) b++; else --b;",
    "        }",
    "",
    "        return l + a * b % (r - l + 1);}",
    "        else {",
    "                ll a = rd();",
    "",
    "                return l + a % (r - l + 1);",
    "        }",
    "}",
    "",
    "void input() {",
    "    ",
    "}",
    "",
    "int32_t main() {",
    "        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
    "        freopen(\"txt.inp\" , \"w\" , stdout);",
    "        srand(time(NULL));",
    "        input();",
    "",
    "        return 0;",
    "}"
  ],
  "description": "randomtest"
},

"polygon-codeforces": {
  "prefix": ["sinhtest" , "ply" , "poly" , "cf"],
  "body": [
    "#include <bits/stdc++.h>",
    "#include <cstdlib>",
    "",
    "using namespace std;",
    "",
    "#define ll long long",
    "#define fi first",
    "#define se second",
    "#define sz size",
    "#define reset(adatma, valdatma) memset(adatma, valdatma, sizeof(adatma))",
    "#define el '\\n'",
    "",
    "const int maxn = 2 * 1e5 + 68;",
    "const int mod = 1e9 + 7;",
    "const int inf = 2 * 1e9 + 1e8 + 6688;",
    "const ll oo = 3 * 1e18 + 1e17 + 666888;",
    "",
    "//  ------------------- d a t m a . _ c o d e r -------------------  //",
    "",
    "mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "ll Rand(ll l, ll r) {",
    "        assert(l <= r);",
    "",
    "        if (r - l + 1 >= 1e9) {",
    "                ll a = rd() / 2, b = rd() / 2;",
    "",
    "                if (a % 2 == 1 && b % 2 == 0) {",
    "                        if (b == 0) b++; else --b;",
    "                }",
    "",
    "                return l + a * b % (r - l + 1);",
    "        } else {",
    "                ll a = rd();",
    "                return l + a % (r - l + 1);",
    "        }",
    "}",
    "",
    "void input(int te) {",
    "        ofstream os;",
    "        ofstream inp((\"test\" + to_string(te) + \".inp\").c_str());",
    "",
    "",
    "}",
    "",
    "int32_t main() {",
    "        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
    "        srand(time(NULL));",
    "",
    "        for (int i = 1 ; i <= 20 ; i++) {",
    "                input(i);",
    "        }",
    "",
    "        return 0;",
    "}"
  ],
  "description": "poly"
},

"code-normal": {
  "prefix": ["nope" , "normal" , "no"],
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "int32_t main() {",
    "        ios_base::sync_with_stdio(false);",
    "        cin.tie(0); cout.tie(0);",
    "",
    "        ",
    "",
    "        return 0;",
    "}"
  ],
  "description": "normal"
},
"gen-bat": {
  "prefix": ["bat" , "win" , "gen" , "cham"],
  "body": [
    "@echo off",
    "",
    "for /l %%i in (1, 1, 100000) do (",
    "",
    "    sinh.exe",
    "    txt.exe ",
    "    test.exe ",
    "    fc txt.out txt.ans > 0 || echo TEST %%i [WRONG ANSWER] && type txt.inp && goto :out",
    "    echo TEST %%i [ACCEPTED]",
    "",
    ")",
    "",
    ":out",
    ""
  ],
  "description": "getbat"
},
"fenwick-tree": {
  "prefix": ["datma-bit" , "datma-fenwick"],
  "body": [
    "struct BIT {",
    "        int bit[2 * N];",
    "",
    "        void update(int idx) {",
    "                for (; idx <= 2 * n ; idx += idx & -idx) ++bit[idx];        ",
    "        }",
    "",
    "        int get(int idx) {",
    "                int res = 0;",
    "",
    "                for (; idx > 0 ; idx &= idx - 1) res += bit[idx];",
    "",
    "                return res;",
    "        }",
    "} fenwick;",
    ""
  ],
  "description": "fenwick-tree"
},
"dp-digit": {
  "prefix": "datma-digit",
  "body": [
    "ll DP(int pos , int last_digit , bool status) {",
    "        if (pos == num.size()) ",
    "                return 1;",
    "",
    "        if (dp[pos][last_digit][status] != -1) ",
    "                return dp[pos][last_digit][status];",
    "",
    "        ll res = 0;",
    "        ",
    "        int limit;",
    "",
    "        if (!status) ",
    "                limit = num[pos];",
    "        else ",
    "                limit = 9;",
    "",
    "        for (int digit = 0 ; digit <= limit ; ++digit) ",
    "                if (digit == last_digit) continue;",
    "                else ",
    "                        if (!status && digit < limit) ",
    "                                res += DP(pos + 1 , digit , !status);",
    "                        else    ",
    "                                res += DP(pos + 1 , digit , status);",
    "",
    "        return dp[pos][last_digit][status] = res;",
    "}"
  ],
  "description": "dp-digit"
},
"clis": {
  "prefix": "datma-clis",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define      ll      long long",
    "#define      fi      first ",
    "#define      se      second ",
    "#define      el      '\\n'",
    "",
    "#define reset(__a , __v) memset(__a,__v,sizeof(__a))",
    "#define datmacoder int32_t main()",
    "#define opf(__dat) if (fopen(__dat\".inp\",\"r\")){freopen(__dat\".inp\",\"r\",stdin);freopen(__dat\".out\",\"w\",stdout);}",
    "#define openfile(__dat) opf(__dat);int _t;if(!TESTCASE)_t=1;else cin>>_t;while(_t--){solve();} ",
    "",
    "template<class A,class B> inline void maximize(A& x, B y) {x = max(x, y);};",
    "template<class A,class B> inline void minimize(A& x, B y) {x = min(x, y);};",
    "",
    "const int maxn = 5e5 + 68;",
    "const int mod = 1e9 + 7;",
    "const int inf = 0x3f3f3f3f;",
    "const ll infll = 0x3f3f3f3f3f3f3f3f;",
    "const bool TESTCASE = false;",
    "",
    "//  ------------------- d a t m a . _ c o d e r -------------------  //",
    "",
    "void add(int &a , int b) {",
    "        a += b;",
    "",
    "        if (a >= mod) a -= mod;",
    "}",
    "",
    "int n;",
    "",
    "struct BIT {",
    "        int len[maxn] , cnt[maxn];",
    "",
    "        void update(int idx , int newlen , int newcnt) {",
    "                while (idx <= n) {",
    "                        if (newlen > len[idx])",
    "                                len[idx] = newlen , ",
    "                                cnt[idx] = newcnt;",
    "                        else ",
    "                                if (newlen == len[idx]) ",
    "                                        add(cnt[idx] , newcnt);",
    "                                ",
    "                        idx += idx & -idx;",
    "                }",
    "        }",
    "",
    "        pair<int , int> get(int idx) {",
    "                int maxlen = 0 , totalc = 0;",
    "",
    "                while (idx > 0) {",
    "                        if (len[idx] > maxlen) ",
    "                                maxlen = len[idx] ,",
    "                                totalc = cnt[idx];      ",
    "                        else ",
    "                                if (len[idx] == maxlen) ",
    "                                        add(totalc , cnt[idx]);",
    "                                ",
    "                        idx -= idx & -idx;",
    "                }",
    "",
    "                return make_pair(maxlen , totalc);",
    "        }",
    "} fenwick;",
    "",
    "int a[maxn];",
    "vector<int> vec;",
    "",
    "void solve() {",
    "        cin >> n;",
    "",
    "        for (int i = 1 ; i <= n ; i++) cin >> a[i] , vec.push_back(a[i]);",
    "",
    "        sort(vec.begin() , vec.end());",
    "        vec.resize(unique(vec.begin() , vec.end()) - vec.begin());",
    "",
    "        for (int i = 1 ; i <= n ; i++) a[i] = lower_bound(vec.begin() , vec.end() , a[i]) - vec.begin() + 1;",
    "",
    "        int maxlen = 0 , totalc = 0;",
    "",
    "        // for (int i = 1 ; i <= n ; i++) cout << a[i] << \" \"; cout << el;",
    "",
    "        for (int i = 1 ; i <= n ; i++) {",
    "                pair<int , int> val = fenwick.get(a[i] - 1);",
    "",
    "                // for (int i = 1 ; i <= n ; i++) cout << fenwick.len[i] << \" \";",
    "",
    "                int len = val.fi;",
    "                int cnt = val.se;",
    "",
    "                // cout << len << \" \" << cnt << el;",
    "",
    "                if (len == 0) cnt = 1;",
    "",
    "                fenwick.update(a[i] , len + 1 , cnt);",
    "",
    "                if (len + 1 > maxlen) ",
    "                        maxlen = len + 1 , ",
    "                        totalc = cnt;",
    "                else ",
    "                        if (len + 1 == maxlen) ",
    "                                add(totalc , cnt);",
    "        }",
    "",
    "        cout << totalc << el;",
    "}",
    "",
    "datmacoder {",
    "        ios_base::sync_with_stdio(false);",
    "        cin.tie(NULL); cout.tie(NULL);",
    "",
    "        openfile(\"txt\");",
    "",
    "        return 0;",
    "}",
    "",
    "/* ",
    "        d a t m a . _ c o d e r",
    "        H O A N G   T H E   T H A N H   D A T",
    "*/"
  ],
  "description": "clis"
},
"floyd-warshall": {
  "prefix": "datma-floyd",
  "body": [
    "void FloydWarshall(void) {",
    "        for (int k = 1 ; k <= n ; k++) ",
    "                for (int u = 1 ; u <= n ; u++) ",
    "                        for (int v = 1 ; v <= n ; v++) ",
    "                                if (w[u][v] > w[u][k] + w[k][v])",
    "                                        w[u][v] = w[u][k] + w[k][v];",
    "}"
  ],
  "description": "floyd-warshall"
},
"bellman-ford": {
  "prefix": "datma-bellman",
  "body": [
    "ll bellman_ford(int _start , int _end) {",
    "        d[_start] = 0;",
    "        ",
    "        for (int i = 1 ; i < n ; i++) ",
    "                for (pair<int , pair<int , int>> pii : e) {",
    "                        int u = pii.se.fi;",
    "                        int v = pii.se.se;",
    "                        ll  w = pii.fi;",
    "",
    "                        if (d[u] != -oo && d[v] < d[u] + w) ",
    "                                d[v] = d[u] + w;",
    "                }",
    "        ",
    "        for (int i = 1 ; i <= n ; i++) ",
    "                for (pair<int , pair<int , int>> pii : e) {",
    "                        int u = pii.se.fi;",
    "                        int v = pii.se.se;",
    "                        ll  w = pii.fi;",
    "",
    "                        if (d[u] != -oo && d[v] < d[u] + w) ",
    "                                d[v] = oo;",
    "                }",
    "",
    "        return d[_end];",
    "}"
  ],
  "description": "bellman-ford"
},
"tarjan": {
  "prefix": "datma-tarjan",
  "body": [
    "void tarjan(int u) {",
    "        num[u] = low[u] = ++curdfs;",
    "",
    "        s.push(u);",
    "",
    "        for (int v : e[u])",
    "                if (!id[v]) ",
    "                        if (!num[v]) {",
    "                                tarjan(v);",
    "                                low[u] = min(low[u] , low[v]);",
    "                        }",
    "                        else    ",
    "                                low[u] = min(low[u] , num[v]);",
    "",
    "        if (num[u] == low[u]) {",
    "                ++curid;",
    "",
    "                int v;",
    "",
    "                do {",
    "                        v = s.top();",
    "                        s.pop();",
    "",
    "                        id[v] = curid;",
    "                } while (v != u);",
    "        }",
    "}"
  ],
  "description": "tarjan"
},
"euler-path": {
  "prefix": "datma-euler-path",
  "body": [
    "void solve() {",
    "        cin >> n >> m;",
    "",
    "        for (int i = 1 ; i <= m ; i++) {",
    "                cin >> u >> v;",
    "",
    "                e[u].push_back(make_pair(v , i));",
    "                e[v].push_back(make_pair(u , i));",
    "        }",
    "",
    "        for (int i = 1 ; i <= n ; i++) ",
    "                if (e[i].size() & 1) ",
    "                        return void(cout << \"IMPOSSIBLE\");",
    "",
    "        st.push(1);",
    "",
    "        reset(vis , false);",
    "",
    "        while (st.size() > 0) {",
    "                bool ok = true;",
    "",
    "                int u = st.top();",
    "",
    "                while (e[u].size() > 0) {",
    "                        int v = e[u].back().fi;",
    "                        int id = e[u].back().se;",
    "",
    "                        e[u].pop_back();",
    "",
    "                        if (!vis[id]) {",
    "                                vis[id] = true;",
    "                                st.push(v);",
    "                                ok = false;",
    "                                break;",
    "                        }",
    "                }",
    "",
    "                if (ok) path.push_back(u) , st.pop();",
    "        }",
    "",
    "        if (path.size() != m + 1)",
    "                cout << \"IMPOSSIBLE\" << el;",
    "        else    ",
    "                for (int i : path) cout << i << \" \"; ",
    "}"
  ],
  "description": "euler-path"
},
"edmonds-karp": {
  "prefix": "datma-edmonds-karp",
  "body": [
    "",
    "        while (q.size() > 0) {",
    "                int u = q.front().fi;",
    "                ll f = q.front().se;",
    "",
    "                q.pop();",
    "",
    "                for (int v : e[u]) ",
    "                        if (trace[v] == 0 && c[u][v] != 0) {",
    "                                trace[v] = u;",
    "",
    "                                ll augment = min(f , c[u][v]);",
    "",
    "                                if (v == t) return augment;",
    "",
    "                                q.push(make_pair(v , augment));",
    "                        }",
    "        }",
    "",
    "        return 0;",
    "}",
    "",
    "ll maxflow(int s = 1 , int t = n) {",
    "        ll res = 0 , augment = 0;",
    "",
    "        while (augment = bfs()) {",
    "                res += augment;",
    "",
    "                int u = t;",
    "",
    "                while (u != s) {",
    "                        int v = trace[u];",
    "",
    "                        c[u][v] += augment;",
    "                        c[v][u] -= augment;",
    "",
    "                        u = v;",
    "                }",
    "        }",
    "",
    "        return res;",
    "}",
    "",
    "int val;",
    "",
    "void solve() {",
    "        cin >> n >> m;",
    "",
    "        for (int i = 1 ; i <= m ; i++) {",
    "                cin >> u >> v >> val;",
    "",
    "                e[u].push_back(v);",
    "                e[v].push_back(u);",
    "",
    "                c[u][v] += val;",
    "        }",
    "",
    "        cout << maxflow() << el;",
    "}"
  ],
  "description": "edmonds-karp"
},
"hop-croft-karp": {
  "prefix": "datma-hop-croft-karp",
  "body": [
    "int n , m , so , ans , u , v;",
    "vector<int> e[maxn];",
    "int d[maxn] , x[maxn] , y[maxn];",
    "",
    "bool bfs() {",
    "        queue<int> q;",
    "",
    "        for (int u = 1 ; u <= n ; u++) ",
    "                if (!x[u]) ",
    "                        d[u] = 0 , ",
    "                        q.push(u);",
    "                else ",
    "                        d[u] = inf;",
    "",
    "        d[0] = inf;",
    "",
    "        while (q.size() > 0) {",
    "                u = q.front();",
    "                q.pop();",
    "",
    "                for (int v : e[u])      ",
    "                        if (d[y[v]] == inf) ",
    "                                d[y[v]] = d[u] + 1 , ",
    "                                q.push(y[v]);",
    "        }",
    "",
    "        return d[0] != inf;",
    "}",
    "",
    "bool dfs(int u) {",
    "        for (int v : e[u]) {    ",
    "                if (!y[v]) {",
    "                        x[u] = v;",
    "                        y[v] = u;",
    "                        d[u] = inf;",
    "",
    "                        return true;",
    "                }",
    "",
    "                if (d[y[v]] == d[u] + 1) ",
    "                        if (dfs(y[v])) {",
    "                                x[u] = v;",
    "                                y[v] = u;",
    "                                d[u] = inf;",
    "",
    "                                return true;",
    "                        }",
    "        }",
    "",
    "        d[u] = inf;",
    "",
    "        return false;",
    "}",
    "",
    "int t;",
    "",
    "void solve() {",
    "        cin >> n >> m >> t;",
    "",
    "        for (int i = 1 ; i <= t ; i++) {",
    "                cin >> u >> v;",
    "",
    "                e[u].push_back(v);",
    "        }",
    "",
    "        int ans = 0;",
    "",
    "        while (bfs() == true) ",
    "                for (int i = 1 ; i <= n ; i++) ",
    "                        if (!x[i]) ",
    "                                if (dfs(i) == true) ++ans;",
    "",
    "        cout << ans << el;",
    "",
    "        for (int i = 1 ; i <= n ; i++) ",
    "                if (x[i] != 0) ",
    "                        cout << i << \" \" << x[i] << el;",
    "}"
  ],
  "description": "hop-croft-karp"
},
"hashing": {
  "prefix": "datma-hashing",
  "body": [
    "ll hashA[maxn] , hashB = 0 , _exp[maxn];",
    "",
    "ll getHash(int i , int j) {",
    "        return (hashA[j] - hashA[i - 1] * _exp[j - i + 1] + mod * mod) % mod;",
    "}",
    "",
    "int n , m;",
    "string a , b;",
    "",
    "void solve() {",
    "        cin >> a >> b;",
    "",
    "        n = a.size();",
    "        m = b.size();",
    "",
    "        a = \" \" + a;",
    "        b = \" \" + b;",
    "",
    "        _exp[0] = 1;",
    "        ",
    "        for (int i = 1 ; i <= n ; i++) ",
    "                _exp[i] = (_exp[i - 1] * base) % mod , ",
    "                hashA[i] = (hashA[i - 1] * base + a[i] - 'a' + 1) % mod;",
    "",
    "        for (int i = 1 ; i <= m ; i++) ",
    "                hashB = (hashB * base + b[i] - 'a' + 1) % mod;",
    "",
    "        for (int i = 1 ; i <= n - m + 1 ; i++) ",
    "                if (hashB == getHash(i , i + m - 1)) cout << i << \" \";",
    "}"
  ],
  "description": "hashing"
},
"manacher": {
  "prefix": "datma-manacher",
  "body": [
    "int manacher(string s) {",
    "        int n = s.size() * 2 - 1;",
    "",
    "        vector<int> f = vector<int>(n , 0);",
    "",
    "        string a = string(n , '.');",
    "",
    "        for (int i = 0 ; i < n ; i += 2) a[i] = s[i / 2];",
    "",
    "        int left = 0 , right = -1 , center , res = 0;",
    "",
    "        for (int i = 0 , j = 0 ; i < n ; i++) {",
    "                j = (i > right ? 0 : min(f[left + right - i] , right - i)) + 1;",
    "",
    "                while (i - j >= 0 && i + j < n && a[i - j] == a[i + j]) ++j;",
    "",
    "                f[i] = --j;",
    "",
    "                if (i + j > right) ",
    "                        right = i + j ,",
    "                        left = i - j;",
    "",
    "                int len = (f[i] + i % 2) / 2 * 2 + 1 - i % 2;",
    "",
    "                if (len > res) ",
    "                        res = len , ",
    "                        center = i;",
    "        }",
    "",
    "        return res;",
    "}"
  ],
  "description": "manacher"
},
"convex-hull": {
  "prefix": "datma-convex-hull",
  "body": [
    "struct point {",
    "    int x , y;",
    "};",
    "",
    "bool ccw(const point &a , const point &b , const point &c) {",
    "    return 1ll * (b.x - a.x) * (c.y - a.y) - 1ll * (c.x - a.x) * (b.y - a.y) >= 0;",
    "}",
    "",
    "vector<point> convexHull(point p[] , int n) {",
    "    sort(p + 1 , p + n + 1 , [](const point &a , const point &b){",
    "        if (a.x != b.x) return a.x < b.x;",
    "        return a.y < b.y;",
    "    });",
    "",
    "    vector<point> hull , hull_up , hull_dw;",
    "",
    "    for (int i = 1 ; i <= n ; i++) {",
    "        while (hull_up.sz() >= 2 && ccw(hull_up[hull_up.sz() - 2] , hull_up.back() , p[i])) {",
    "            hull_up.pop_back();",
    "        }",
    "",
    "        hull_up.push_back(p[i]);",
    "    }",
    "",
    "    for (int i = n ; i >= 1 ; i--) {",
    "        while (hull_dw.sz() >= 2 && ccw(hull_dw[hull_dw.sz() - 2] , hull_dw.back() , p[i])) {",
    "            hull_dw.pop_back();",
    "        }",
    "",
    "        hull_dw.push_back(p[i]);",
    "    }",
    "",
    "    hull_dw.pop_back(); hull_dw.erase(hull_dw.begin());",
    "",
    "    for (point i : hull_up) hull.push_back(i);",
    "    for (point i : hull_dw) hull.push_back(i);",
    "",
    "    return hull;",
    "}",
    "",
    "int n;",
    "point p[N];",
    "",
    "void input() {",
    "    cin >> n;",
    "",
    "    for (int i = 1 ; i <= n ; i++) {",
    "        cin >> p[i].x >> p[i].y;",
    "    }",
    "}",
    "",
    "void solve() { ",
    "    vector<point> HULL = convexHull(p , n);",
    "",
    "    cout << HULL.sz();",
    "}"
  ],
  "description": "convex-hull"
},
"trie": {
  "prefix": "datma-trie",
  "body": [
    "struct node {",
    "    node* child[26];",
    "    int cnt;",
    "",
    "    node() {",
    "        reset(child , 0);",
    "        cnt = 0;",
    "    }",
    "};",
    "",
    "node* root = new node();",
    "",
    "void add(string &s) {",
    "    node* u = root;",
    "",
    "    for (char ch : s) {",
    "        int k = ch - 'a';",
    "",
    "        if (u -> child[k] == 0) u -> child[k] = new node();",
    "",
    "        u = u -> child[k];",
    "",
    "        u -> cnt++;",
    "    }",
    "}",
    "",
    "void input() {",
    "    cin >> n;",
    "",
    "    while (n--) {",
    "        cin >> s;",
    "        add(s);",
    "    }",
    "}",
    "",
    "int get(string &s) {",
    "    node* u = root;",
    "",
    "    for (char ch : s) {",
    "        int k = ch - 'a';",
    "",
    "        if (u -> child[k] == 0) return 0;",
    "",
    "        u = u -> child[k];",
    "    }",
    "",
    "    return u -> cnt;",
    "}",
    "",
    "void solve() { ",
    "    int m ; cin >> m;",
    "",
    "    while (m--) {",
    "        cin >> s;",
    "",
    "        cout << get(s) << el;",
    "    }",
    "}"
  ],
  "description": "trie"
},
"hld": {
  "prefix": "datma-hld",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "using namespace std;",
    "",
    "#define      ll      long long",
    "#define      fi      first ",
    "#define      se      second ",
    "#define      el      '\\n'",
    "",
    "#define reset(__a , __v) memset(__a,__v,sizeof(__a))",
    "#define datmacoder int32_t main()",
    "#define opf(__dat) if (fopen(__dat\".inp\",\"r\")){freopen(__dat\".inp\",\"r\",stdin);freopen(__dat\".out\",\"w\",stdout);}",
    "#define openfile(__dat) opf(__dat);int _t;if(!TESTCASE)_t=1;else cin>>_t;while(_t--){solve();} ",
    "",
    "template<class A,class B> inline void maximize(A& x, B y) {x = max(x, y);};",
    "template<class A,class B> inline void minimize(A& x, B y) {x = min(x, y);};",
    "",
    "const int maxn = 2e5 + 68;",
    "const int mod = 1e9 + 7;",
    "const int inf = 0x3f3f3f3f;",
    "const ll infll = 0x3f3f3f3f3f3f3f3f;",
    "const bool TESTCASE = false;",
    "",
    "//  ------------------- d a t m a . _ c o d e r -------------------  //",
    "",
    "int n , q , type , u , v , a[maxn];",
    "vector<int> e[maxn];",
    "",
    "int sz[maxn] , deep[maxn] , par[maxn];",
    "",
    "void dfs(int u , int p = 0) {",
    "        sz[u] = 1;",
    "",
    "        for (int v : e[u]) ",
    "                if (v != p) {",
    "                        deep[v] = deep[u] + 1;",
    "                        ",
    "                        par[v] = u;",
    "",
    "                        dfs(v , u);",
    "",
    "                        sz[v] += sz[u];",
    "                }",
    "}",
    "",
    "int pos[maxn] , id[maxn] , head[maxn] , curID = 0 , curPos = 0;",
    "",
    "void hld(int u , int p = 0) {",
    "        if (!head[curID]) ",
    "                head[curID] = u;",
    "        ",
    "        pos[u] = ++curPos;",
    "        id[u] = curID;",
    "",
    "        int heavy = 0;",
    "",
    "        for (int v : e[u]) ",
    "                if (v != p) ",
    "                        if (sz[heavy] < sz[v]) ",
    "                                heavy = v;",
    "        ",
    "        if (heavy != 0) ",
    "                hld(heavy , u);",
    "",
    "        for (int v : e[u]) ",
    "                if (v != p && v != heavy) ",
    "                        ++curID , ",
    "                        hld(v , u);",
    "}",
    "",
    "int lca(int u , int v) {",
    "        while (id[u] != id[v]) ",
    "                if (id[u] > id[v]) ",
    "                        u = par[head[id[u]]];",
    "                else    ",
    "                        v = par[head[id[v]]];",
    "        ",
    "        return (deep[u] > deep[v] ? v : u);",
    "}",
    "",
    "struct SegmentTree {",
    "        int tree[maxn * 4];",
    "",
    "        void update(int id , int l , int r , int idx , int val) {",
    "                if (l > idx || r < idx) return;",
    "",
    "                if (l == r) {",
    "                        tree[id] = val;",
    "                        return;",
    "                }",
    "",
    "                int mid = l + r >> 1;",
    "",
    "                update(id << 1 , l , mid , idx , val);",
    "                update(id << 1 | 1 , mid + 1 , r , idx , val);",
    "",
    "                tree[id] = max(tree[id << 1] , tree[id << 1 | 1]);",
    "        }",
    "",
    "        int get(int id , int l , int r , int u , int v) {",
    "                if (l > v || r < u) return 0;",
    "",
    "                if (l >= u && r <= v) return tree[id];",
    "",
    "                int mid = l + r >> 1;",
    "",
    "                int left = get(id << 1 , l , mid , u , v);",
    "                int right = get(id << 1 | 1 , mid + 1 , r , u , v);",
    "",
    "                return max(left , right);",
    "        }",
    "} it;",
    "",
    "void solve() {",
    "        cin >> n >> q;",
    "",
    "        for (int i = 1 ; i <= n ; i++) cin >> a[i];",
    "",
    "        for (int i = 1 ; i < n ; i++) {",
    "                cin >> u >> v;",
    "",
    "                e[u].push_back(v);",
    "                e[v].push_back(u);",
    "        }",
    "",
    "        dfs(1); hld(1);",
    "",
    "        for (int i = 1 ; i <= n ; i++) ",
    "                it.update(1 , 1 , n , pos[i] , a[i]);",
    "",
    "        for (int i = 1 ; i <= q ; i++) {",
    "                cin >> type >> u >> v;",
    "",
    "                if (type & 1)",
    "                        it.update(1 , 1 , n , pos[u] , v);",
    "                else {",
    "                        int p = lca(u , v);",
    "",
    "                        int res = 0;",
    "",
    "                        while (id[u] > id[p]) ",
    "                                maximize(res , it.get(1 , 1 , n , pos[head[id[u]]] , pos[u])) , ",
    "                                u = par[head[id[u]]];",
    "",
    "                        while (id[v] > id[p]) ",
    "                                maximize(res , it.get(1 , 1 , n , pos[head[id[v]]] , pos[v])) , ",
    "                                v = par[head[id[v]]];",
    "",
    "                        if (deep[u] > deep[v]) ",
    "                                maximize(res , it.get(1 , 1 , n , pos[v] , pos[u]));",
    "                        else ",
    "                                maximize(res , it.get(1 , 1 , n , pos[u] , pos[v]));",
    "",
    "                        cout << res << \" \";",
    "                }",
    "        }",
    "}",
    "",
    "datmacoder {",
    "        ios_base::sync_with_stdio(false);",
    "        cin.tie(NULL); cout.tie(NULL);",
    "",
    "        openfile(\"nofile\");",
    "",
    "        return 0;",
    "}",
    "",
    "/* ",
    "        d a t m a . _ c o d e r",
    "        H O A N G   T H E   T H A N H   D A T",
    "*/"
  ],
  "description": "hld"
}

}
